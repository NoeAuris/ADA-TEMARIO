Ciclos avanzado. None. Virtualenv. Ejecuci√≥n de scripts. Modulos, Modulo datetime.
Repaso: Diferencias entre listas y diccionarios
Como sucede con un diccionario convencional, un diccionario en Python es una palabra que tiene asociado algo. Al contrario de lo que suced√≠a en las listas, los diccionarios no tienen orden. El √≠ndice de la lista debe ser un n√∫mero entero y el √≠ndice del diccionario puede ser casi de cualquier tipo.

Conjuntos
Aunque se usan con menos frecuencia, python tambi√©n dispone de conjuntos (sets).

La mayor facilidad que nos dan los conjuntos son las operaciones:

A | B: Uni√≥n entre el conjunto A y B (Los elementos del conjunta A y los elementos del conjunto B)
A & B: Intersecci√≥n entre el conjunto A y B (los elementos que est√°n en ambos conjuntos)
A ‚Äì B: Diferencia entre el conjunto A y B (los elementos que est√°n en A pero no est√°n en B)
A ^B: Diferencia sim√©trica entre el conjunto A y B (los elementos que est√°n en A o en B pero no en los dos)
Veamos el ejemplo:

>>> set([1,1,1,2,2,3,4,6])
{1, 2, 3, 4, 6}
>>> set([1,1,1,2,2,3,4,6]) - set([1,2])
{3, 4, 6}
>>> set([1,1,1,2,2,3,4,6]) | set([1,2])
{1, 2, 3, 4, 6}

Ciclos avanzado
break
La sentencia break nos permite alterar el comportamiento de los bucles while y for. Concretamente, permite terminar con la ejecuci√≥n del bucle. Esto significa que una vez se encuentra la palabra break, el bucle se habr√° terminado.

Break con bucles for
Veamos como podemos usar el break con bucles for. El range(5) generar√≠a 5 iteraciones, donde la i valdr√≠a de 0 a 4. Sin embargo, en la primera iteraci√≥n, terminamos el bucle prematuramente.

En este ejemplo el ciclo se termina despues de la primera iteracion:

for i in range(5):
    print(i)
    break
    # No llega

Un ejemplo un poco m√°s √∫til, ser√≠a el de buscar una letra en una palabra. Se itera toda la palabra y en el momento en el que se encuentra la letra que busc√°bamos, se rompe el bucle y se sale. Esto es algo muy √∫til porque si ya encontramos lo que est√°bamos buscando, no tendr√≠a mucho sentido seguir iterando la lista, ya que desperdiciar√≠amos recursos.

cadena = 'Python'
for letra in cadena:
    if letra == 'h':
        print("Se encontr√≥ la h")
        break
    print(letra)

# Salida:
# P
# y
# t
# Se encontr√≥ la h

Break con bucles while
El break tambi√©n nos permite alterar el comportamiento del while. Veamos un ejemplo.

La condici√≥n while True har√≠a que la secci√≥n de c√≥digo se ejecutara indefinidamente, pero al hacer uso del break, el bucle se romper√° cuando x valga cero.

x = 5
while True:
    x -= 1
    print(x)
    if x == 0:
        break
    print("Fin del bucle")

#4, 3, 2, 1, 0

Por norma general, y salvo casos muy concretos, si ves un while True, es probable que haya un break dentro del bucle.

Break y bucles anidados
Como hemos dicho, el uso de break rompe el bucle, pero s√≥lo aquel en el que est√° dentro.

Es decir, si tenemos dos bucles anidados, el break romper√° el bucle anidado, pero no el exterior.

for i in range(0, 4):
    for j in range(0, 4):
        break
        #Nunca se realiza m√°s de una iteraci√≥n
    # El break no afecta a este for
    print(i, j)

# 0 0
# 1 0
# 2 0
# 3 0

continue
El uso de continue al igual que el ya visto break, nos permite modificar el comportamiento de de los bucles while y for. Concretamente, continue se salta todo el c√≥digo restante en la iteraci√≥n actual y vuelve al principio en el caso de que a√∫n queden iteraciones por completar. La diferencia entre el break y continue es que el continue no rompe el bucle, si no que pasa a la siguiente iteraci√≥n saltando el c√≥digo pendiente.

En el siguiente ejemplo vemos como al encontrar la letra P se llama al continue, lo que hace que se salte el print(). Es por ello por lo que no vemos la letra P impresa en pantalla.

cadena = 'Python'
for letra in cadena:
    if letra == 'P':
        continue
    print(letra)
# Salida:
# y
# t
# h
# o
# n

A diferencia del break, el continue no rompe el bucle sino que finaliza la iteraci√≥n actual, haciendo que todo el c√≥digo que va despu√©s se salte, y se vuelva al principio a evaluar la condici√≥n.

En el siguiente ejemplo podemos ver como cuando la x vale 3, se llama al continue, lo que hace que se salte el resto de c√≥digo de la iteraci√≥n (el print()). Por ello, vemos como el n√∫mero 3 no se imprime en pantalla.

x = 5
while x > 0:
    x -= 1
    if x == 3:
        continue
    print(x)

#Salida: 4, 2, 1, 0

Iterar con zip
La funci√≥n zip() de Python viene incluida por defecto en el namespace, lo que significa que puede ser usada sin tener que importarse. De acuerdo con la documentaci√≥n oficial:

Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The iterator stops when the shortest input iterable is exhausted.

Dicho de otra manera, si pasamos dos listas a zip como entrada, el resultado ser√° una tupla donde cada elemento tendr√° todos y cada uno de los elementos i-√©simos de las pasadas como entrada.

Veamos un ejemplo. Como podemos ver, el resultado tras aplicar zip es una lista con a[0]b[0] en el primer elemento y a[1]b[1] como segundo.

a = [1, 2]
b = ["Uno", "Dos"]
c = zip(a, b)

print(list(c))
# [(1, 'Uno'), (2, 'Dos')]

A priori puede parecer una funci√≥n no muy relevante, pero es realmente √∫til combinada con un for para iterar dos listas en paralelo.

a = [1, 2]
b = ["Uno", "Dos"]
c = zip(a, b)

for numero, texto in zip(a, b):
    print("N√∫mero", numero, "Letra", texto)
    
# N√∫mero 1 Letra Uno
# N√∫mero 2 Letra Dos

zip() con n argumentos
Ya hemos visto el uso de zip con dos listas, pero dado que est√° definida como zip(iterables), es posible pasar un n√∫mero arbitrario de iterables como entrada.

Veamos un ejemplo con varias listas. Es importante notar que todas tienen la misma longitud, dos.

numeros = [1, 2]
espanol = ["Uno", "Dos"]
ingles = ["One", "Two"]
frances = ["Un", "Deux"]
c = zip(numeros, espanol, ingles, frances)

for n, e, i, f in zip(numeros, espanol, ingles, frances):
    print(n, e, i, f)
    
# 1 Uno One Un
# 2 Dos Two Deux


Tambi√©n podemos usar zip usando iterables de diferentes longitudes. En este caso lo que pasar√° es que el iterador para cuando la lista m√°s peque√±a se acaba.

numeros = [1, 2, 3, 4, 5]
espanol = ["Uno", "Dos"]

for n, e in zip(numeros, espanol):
    print(n, e)

# 1 Uno
# 2 Dos

Resulta l√≥gico que este sea el comportamiento, porque de no ser as√≠ y se continuara, no tendr√≠amos valores para usar.

Iterar con enumerate
El uso del for en Python nos permite iterar colecciones, recorriendo todos los elementos de la misma.

lista = ["A", "B", "C"]

for l in lista:
    print(l)

# Salida:
# A
# B
# C

Sin embargo, existen situaciones en las que no solo queremos acceder al elemento i-√©simo de la colecci√≥n, sino que adem√°s queremos el √≠ndice. Una forma de hacerlo ser√≠a la siguiente.

lista = ["A", "B", "C"]

indice = 0
for l in lista:
    print(indice, l)
    indice += 1

# Salida:
# 0 A
# 1 B
# 2 C

Aunque se trata de una forma perfectamente v√°lida, no es demasiado pyth√≥nica, y es precisamente donde entra en juego el enumerate(). Su uso nos permite ahorrar alguna que otra l√≠nea de c√≥digo, obteniendo un resultado mucho m√°s limpio y claro.

lista = ["A", "B", "C"]

for indice, l in enumerate(lista):
    print(indice, l)

# Salida:
# 0 A
# 1 B
# 2 C

Por √∫ltimo, es importante notar que su uso no se limita √∫nicamente a bucles for. Podemos convertir el tipo enumerate en una lista de tuplas, donde cada una contiene un elemento de la colecci√≥n inicial y el √≠ndice asociado.

lista = ["A", "B", "C"]

en = list(enumerate(lista))
print(en)

# Salida;
# [(0, 'A'), (1, 'B'), (2, 'C')]

Por lo tanto recuerda, la pr√≥xima vez que quieras acceder a los √≠ndices de una colecci√≥n, piensa si tal vez enumerate puede resolver tu problema de manera m√°s clara y con menos c√≥digo.

None
El objeto None de Python, denota falta de valor. Este objeto no tiene m√©todos.

Ya sabemos que Python es un lenguaje de ¬´tipado¬ª din√°mico, es decir, no es necesario inidicar de qu√© tipo de dato es una variable al momento de crearla ni tampoco que la misma mantenga ese tipo de dato a lo largo de la ejecuci√≥n del programa: puede comenzar siendo un entero, luego una cadena, luego un n√∫mero de coma flotante, etc. No obstante, todas las variables tienen alg√∫n tipo de dato (para ser m√°s precisos, en realidad, son instancias de alguna clase; pero esto no nos interesa todavia) que podemos conocer v√≠a la funci√≥n incorporada type():

>>> pi = 3.14
>>> type(pi)
<class 'float'>

Los cuatro tipos de dato b√°sicos son el n√∫mero entero (int), el n√∫mero de coma flotante (float), la cadena de caracteres (str) y el booleano (bool). Sin embargo, Python incorpora un quinto tipo de dato que estrictamente hablando se llama NoneType y cuyo √∫nico valor posible es None (pronunciado llanamente ¬´nan¬ª).

>>> a = None
>>> type(a)
<class 'NoneType'>

A menudo None es utilizado cuando se quiere crear una variable (puesto que Python no distingue la creaci√≥n de la asignaci√≥n: crear una variable es simplemente darle un valor) pero a√∫n no se le quiere asignar ning√∫n valor en particular.

Una variable puede empezar siendo None y luego ser asignada con otro valor.

>>> a = None
>>> type(a)
<class 'NoneType'>
>>> a = "Hola mundo"
>>> type(a)
<class 'str'>

N√≥tese que cuando escribimos el nombre de una variable en la consola interactiva cuyo contenido es None, no se mostrar√° nada.

>>> a = None
>>> a
>>>

Dado que se trata de un tipo de dato como cualquier otro, con la peculiaridad de que tiene un √∫nico valor posible, podemos realizar las comparaciones habituales.

a = None
if a == None:
    print("a es None.")
else:
    print("a no es None.")

Si bien esto es v√°lido, la forma recomendada de hacer comparaciones con este tipo de dato es utilizando la palabra reservada is (v√©ase m√°s abajo la explicaci√≥n t√©cnica de esto).

variable_a = None
# M√©todo recomendado de comparaci√≥n.
if variable_a is None:
    print("a es None.")
else:
    print("a no es None.")
# o en caso de querer validar que NO sea None
variable_a = 1
variable_b = 2
# V√°lido.
if not variable_a is None:
    print("a no es None.")
# V√°lido y m√°s legible.
if variable_n is not None:
    print("b no es None.")

Las dos comparaciones son similares, pero la segunda es la m√°s recomendada.

Ambiente virtual (virtualenv)
Nos permite encapsular un proyecto para poder instalar las versiones de los paquetes que se requieran sin tenerlos que instalar en todo el sistema operativo. Esto evita conflictos de paquetes en el int√©rprete principal.

Scripts
En inform√°tica, un script, secuencia de comandos o guion (traduciendo desde ingl√©s) es un t√©rmino informal que se usa para designar a un programa relativamente simple. En nuestro caso, para resolver los ejercicios integradores 1, vamos a tener que escribir distintos scripts o programitas.

Ejemplo script simple en Python
mi_primer_script.py

def multiply(numero_a, numero_b):
    return float(numero_a) * float(numero_b)


def main():
    # Aqui inicia el programa
    numero_a = input('Inserte un n√∫mero: ')
    numero_b = input('Inserte otro n√∫mero: ')
    res = multiply(numero_a, numero_b)
    print(f'La multiplicaci√≥n es {res}')
    # Aqui finaliza el programa

if __name__ == '__main__':
    main()

Prestar atenci√≥n a __main__ que indica el comienzo del programa: La funci√≥n main() desempe√±a un doble papel: cuando elaboramos un programa, un script con varias funciones def en su interior, a veces se hace necesario proporcionar un ORDEN DE JERARQU√çA al int√©rprete de Python para que √©ste sepa por qu√© funci√≥n debe comenzar a ejecutarse nuestro script.

M√≥dulos: from, import
El uso de from e import nos permite importar m√≥dulos o librer√≠as, tanto est√°ndar de Python como externas o definidas por nosotros. En ejemplos como este es donde podemos ver que la sintaxis de Python se asemeja bastante al lenguaje natural: de collections importa namedtuple.

from collections import namedtuple

Un m√≥dulo nos permitir√° organizar l√≥gicamente el c√≥digo Python. Agrupando c√≥digo relacionado dentro de un m√≥dulo hace el c√≥digo mas f√°cil de entender y usar. Un m√≥dulo es un objeto de Python con atributos con nombres arbitrarios que puede enlazar y hacer referencia.

Simplemente, un m√≥dulo es no es otra cosa sino un archivo con extensi√≥n .py. Un m√≥dulo puede definir funciones, clases y variables, tambi√©n puede incluir c√≥digo ejecutable.

A continuaci√≥n un ejemplo de un simple m√≥dulo llamado utilidades.py:

""" M√≥dulo para c√°lculos diversos """

def precio_con_descuento(precio_original, descuento):
    """Calcula y retorna el precio con descuento."""
    nuevo_precio = (100 - descuento) * precio_original / 100
    return nuevo_precio

def suma_lista(lista_de_numeros):
    resultado = 0
    for numero in lista_de_numeros:
        resultado += numero
    return resultado



Sentencia import
La sentencia import se utiliza para importar un m√≥dulo. Usted puede usar cualquier archivo de c√≥digo Python como un m√≥dulo ejecutando esta sentencia en otro archivo de c√≥digo Python. La sentencia import tiene la siguiente sintaxis:

import os

Cuando el interprete encuentra una sentencia import, este importa el m√≥dulo si el mismo esta presente en la ruta de b√∫squeda. Una ruta de b√∫squeda es una lista de directorios que el interprete busca antes de importar un m√≥dulo.

Por ejemplo, al importar el m√≥dulo utilidades.py, usted necesita colocar la siguiente sentencia al tope del otro script Python. A continuaci√≥n un ejemplo de un simple m√≥dulo, calculo_factura.py (tener en cuenta que debemos estar en el mismo directorio que el modulo utilidades.py)

# Importar el modulo llamado "utilidades"
import utilidades


print(f"El precio de una heladera de 15000 con 30\% de descuento es {utilidades.precio_con_descuento(15000, 30)}")
print(f"El total del carrito es {utilidades.suma_lista([456,222,12])}")



La primera vez que un m√≥dulo es importado en un script de Python, se ejecuta su c√≥digo una vez. Si otro m√≥dulo importa el mismo m√≥dulo este no se cargar√° nuevamente; los m√≥dulos son inicializados una sola vez.

Modulo datetime
https://docs.python.org/es/3/library/datetime.html

Existe un modulo de Python que nos permite trabajar con fechas y d√≠as. Para utilizarlo necesitamos importarlo:

import datetime

El m√≥dulo datetime proporciona clases para manipular fechas y horas. Si bien la implementaci√≥n permite operaciones aritm√©ticas con fechas y horas, su principal objetivo es poder extraer campos de forma eficiente para su posterior manipulaci√≥n o formateo.

Ejemplos:

ayer = datetime.date(2021, 11, 1)
ayer.replace(day=26)
hoy = datetime.date.today()

Fechas futuras y pasadas pueden calcularse usando aritm√©tica b√°sica en dos objetos datetime, o combinando datetime con un timedelta. Restar fechas produce un timedelta, y un timedelta se puede agregar o restar de una fecha para producir otra fecha. Los valores internos para un timedelta son almacenados en d√≠as, segundos y microsegundos.

from datetime import date
today = date.today()
my_birthday = date(today.year, 7, 3)
time_to_birthday = my_birthday - today
time_to_birthday.days  # El resultado es un tipo de dato timedelta


Para leer mas de aritm√©tica de fechas pueden ir a https://rico-schmidt.name/pymotw-3/datetime/index.html

üöÄ Recursos de la clase
https://ellibrodepython.com/modulos-python https://j2logo.com/python/tutorial/tipo-set-python/ https://openlibra.com/es/book/download/introduccion-a-la-programacion-con-python-2 https://www.freecodecamp.org/espanol/news/python-if-name-main/ https://elpythonista.com/script-en-python