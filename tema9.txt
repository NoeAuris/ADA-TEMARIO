Clases - Git
Ejercicios de la clase pasada
Vimos un poco de esto en la clase 5. En la teor√≠a de la clase anterior tenemos algunos ejemplos de Herencia y Polimorfismo.

Clases y Objetos - Resumen
Los objetos son formas ordenadas de agrupar datos (atributos) y operaciones sobre estos datos (m√©todos).

Cada objeto es de una clase o tipo, que define cu√°les ser√°n sus atributos y m√©todos. Y cuando se crea una variable de una clase en particular, se crea una instancia de esa clase.

Para nombrar una clase definida por el programador, se suele una letra may√∫scula al comienzo de cada palabra.

El constructor de una clase es el m√©todo que se ejecuta cuando se crea una nueva instancia de esa clase. ( 'init')

Es posible definir una gran variedad de m√©todos dentro de una clase, incluyendo m√©todos especiales que pueden utilizados para mostrar, sumar, comparar u ordenar los objetos.

Encapsulamiento
En programaci√≥n modular, y m√°s espec√≠ficamente en programaci√≥n orientada a objetos, se denomina encapsulamiento al ocultamiento del estado, es decir, de los datos miembro de un objeto de manera que solo se pueda cambiar mediante las operaciones definidas para ese objeto.

Cada objeto est√° aislado del exterior, es un m√≥dulo natural, y la aplicaci√≥n entera se reduce a un agregado o rompecabezas de objetos. El aislamiento protege a los datos asociados de un objeto contra su modificaci√≥n por quien no tenga derecho a acceder a ellos, eliminando efectos secundarios e interacciones.

De esta forma el usuario de la clase puede obviar la implementaci√≥n de los m√©todos y propiedades para concentrarse solo en c√≥mo usarlos. Por otro lado se evita que el usuario pueda cambiar su estado de maneras imprevistas e incontroladas.

Atributos protegidos en Python ('____')
A menudo podemos encontrarnos cuando andamos buscando ejemplos de alg√∫n c√≥digo con algo como esto:

class Usuario(object):
    def __init__(self, nombre, clave):
        self.nombre = nombre
        self._clave = clave  # 1 guion bajo para indicar que est√° protegido


usuario1 = Usuario("Roberto", "qwerty")
print(usuario1.nombre, usuario1._clave)

Resultado: (‚ÄòRoberto‚Äô, ‚Äòqwerty‚Äô)

Como ves el atributo clave esta precedido por un gui√≥n bajo, lo que indica que es un atributo protegido. Lo cual establece que solo puede ser accedido por esa clase y sus sub-clases, es decir, aquellas que hereden de la clase padre. Se suele ver muy a menudo como una buena practica para atributos o m√©todos de uso interno y tambi√©n para evitar la colisi√≥n de los mismos nombres de m√©todos o atributos causado por herencia. Siempre y cuando estemos hablando de programas que recurren a muchas clases, es probable que los veas utilizar.

De lo contrario, resulta, en realidad, innecesario.

Atributos privados en Python ('____')
En el caso de un atributo privado estamos indicando que este solo podr√° ser accedido o modificado si se especifica la clase precedida por un gui√≥n bajo seguida del atributo precedido por doble gui√≥n bajo.

class Usuario(object):
    def __init__(self, nombre, clave):
        self.nombre = nombre
        self.__clave = clave  # 2 guiones bajos para indicar que est√° protegido
        
usuario1 = Usuario("Roberto", "qwerty")
print (usuario1.nombre, usuario1.__clave)


Si hacemos esto obtendremos de salida que no existe el atributo clave que estamos intentando imprimir.

AttributeError: ‚Äòusuario‚Äô object has no attribute ‚Äò__clave‚Äô

@Property en python
La funci√≥n integrada property() nos permitir√° interceptar la escritura, lectura, borrado de los atributos y ademas nos permiten incorporar una documentaci√≥n sobre los mismos. La sintaxis para invocarla es la siguiente:

@property Si, es un decorador.

Si nosotros no pasamos alguno de los par√°metros su valor por defecto sera None.

Getter: Se encargar√° de interceptar la lectura del atributo. (get = obtener)

Setter : Se encarga de interceptar cuando se escriba. (set = definir o escribir)

Deleter : Se encarga de interceptar cuando es borrado. (delete = borrar)

class Perro(object): #Declaramos la clase principal Perros
    def __init__(self, nombre, peso): #Definimos los par√°metros 
        self.__nombre = nombre #Declaramos los atributos (privados ocultos)
        self.__peso = peso
   
    @property # Getter
    def nombre(self): #Definimos el m√©todo para obtener el nombre
        return self.__nombre #Aqu√≠ simplemente estamos retornando el atributo privado oculto

    #Hasta aqu√≠ definimos los m√©todos para obtener los atributos ocultos o privados getter.
    #Ahora vamos a utilizar setter y deleter para modificarlos
    @nombre.setter # Setter
    def nombre(self, nuevo):
        print ("Modificando nombre..")
        self.__nombre = nuevo
        print ("El nombre se ha modificado por")
        print (self.__nombre) #Aqu√≠ vuelvo a pedir que retorne el atributo para confirmar

    @nombre.deleter # Deleter
    def nombre(self): 
        print("Borrando nombre..")
        del self.__nombre


>>> tomas = Perro('Tom', 27)
>>> print (tomas.nombre) #Imprimimos el nombre de Tomas. Se hace a trav√©s de getter
>>> tomas.nombre = 'Tomasito' #Cambiamos el atributo nombre que se hace a trav√©s de setter


Resultado:

Tom
Modificando nombre..
El nombre se ha modificado por
Tomasito

Se define primero property y luego de ella el m√©todo mediante el cual retornamos el nombre (get) que en este caso al ser el primer m√©todo luego de property lo toma autom√°ticamente como Getter (linea 10). Luego especificamos el (set) que nos permite lanzar un print al modificar el atributo privado nombre.

(Tarea para la clase que viene) Git
Un poco de historia
Hasta principios de la d√©cada de 2000, los programadores sol√≠an compartir su trabajo de persona a persona. A medida que un proyecto sumaba m√°s colaboradores, este m√©todo se volvi√≥ lento, propenso a errores y poco eficaz. Los sistemas de control de versiones nacieron para dar respuesta a esas necesidades. Con esas herramientas, los desarrolladores pudieron hacer las mismas tareas m√°s f√°cilmente.

En 2002, la comunidad del kernel Linux fue una de las primeras en adoptar un sistema de control de versiones conocido como BitKeeper. Alg√∫n tiempo despu√©s, Linus Torvalds ide√≥ Git y lo lanz√≥ en mayo de 2005 tras un conflicto con BitKeeper. Dos meses despu√©s, un ingeniero de software japon√©s llamado Junio Hamano fue nombrado mantenedor, funci√≥n que sigue desempe√±ando hasta hoy.

Las soluciones basadas en la web, como GitHub, Bitbucket o GitLab, no deben confundirse con Git propiamente dicho. Estas herramientas s√≥lo proporcionan espacio para almacenar c√≥digo en la nube y una interfaz amigable para realizar diversas operaciones. En estos posts utilizaremos GitHub, pero el proceso es muy similar si eliges una de las otras opciones.

T√©rminos frecuentes
Antes de seguir avanzando, conviene definir algunos t√©rminos comunes que encontraremos m√°s adelante:

Un repositorio es una carpeta que contiene los archivos y subdirectorios de un proyecto. Puede ser p√∫blico o privado, dependiendo de qui√©n deba tener acceso.

Una rama es una ruta de desarrollo separada en el mismo repositorio. En un mismo proyecto suelen utilizarse ramas separadas para trabajar en nuevas caracter√≠sticas sin interferir con la versi√≥n de producci√≥n. Una vez que el c√≥digo es revisado y probado, un administrador del repositorio puede fusionar los cambios en la rama principal.

Un commit es una instant√°nea de un repositorio en un momento dado. Permite a los programadores incluir comentarios y pedir la opini√≥n de otras personas. Usando el hash que lo identifica puedes volver a un estado anterior del proyecto si es necesario. Antes de que los archivos y directorios puedan ser comiteados, necesitamos decirle a Git que los rastree. Normalmente nos referimos a este paso simplemente como agregar los archivos al √°rea de staging.

Un pull request (o simplemente PR) es un m√©todo para informar a otros desarrolladores y discutir los cambios recientes antes de incorporarlos a la ruta de desarrollo principal.

Un fork es un proyecto independiente que se basa en un repositorio determinado. A diferencia de las ramas, no es local a este √∫ltimo. Sin embargo, tambi√©n puede fusionarse con √©l a trav√©s de un pull request adecuado.

Se puede utilizar un archivo .gitignore para indicar qu√© contenido local no queremos incluir en el repositorio. Esto nos ayuda a evitar enviar archivos temporales o exponer informaci√≥n sensible en una soluci√≥n basada en la web. Con esto en mente, vamos a hacer una introducci√≥n a Git desde cero y aprovechar GitHub para un proyecto de desarrollo de software. Aunque sencillo, el ejemplo que vamos a trabajar en los pr√≥ximos posts nos ayudar√° a ilustrar los conceptos fundamentales de los sistemas de control de versiones. ¬°Nos leemos en breve!

Creaci√≥n y configuraci√≥n de la cuenta
Lo primero que necesitamos es una cuenta de usuario gratuita. Simplemente hay que visitar https://github.com, elegir un nombre de usuario que no est√© ya en uso, un correo y una contrase√±a, y pulsar el bot√≥n verde grande ‚ÄúSign up for GitHub‚Äù.

Lo siguiente que ver√°s es la p√°gina de precios para planes mejores, pero lo puedes ignorar por el momento. GitHub te enviar√° un correo para verificar la direcci√≥n que les has dado. Confirmar la direcci√≥n desde el email recibido.

Pasarle a la Profe el nombre de usuario y email.

üöÄ Recursos de la clase
https://github.com/

https://uniwebsidad.com/libros/algoritmos-python