OOP. Clases
Ejercicios y dudas clase pasada
Cuestionario para charlar dudas
https://forms.gle/P2PszNKFtxBwAdbz8

C√≥digo del cuestionario
https://www.online-python.com/Anz5yDcjZ3

datetime avanzado
La clase pasada hicimos algunos ejemplos con el modulo datetime. Agrego aqui una serie de ejemplos √∫tiles:

# datetime.now(): para obtener la fecha y hora actuales.
>>> marca_temporal = datetime.now()
>>> print(marca_temporal)
2021-07-22 21:15:45.775099
>>> marca_temporal.year
2021
>>> marca_temporal.hour
21
# datetime.date(): obtener la fecha del objeto datetime.
>>> marca_temporal.date()
datetime.date(2021, 7, 22)
# datetime.time(): obtener la hora del objeto datetime. Con este m√©todo y el m√©todo now() podemos obtener la hora actual.
>>> marca_temporal.time()
datetime.time(21, 15, 45, 775099)
# datetime.replace(): es el m√©todo hom√≥nimo a los vistos en las clases date y time, cuya funci√≥n es sustituir valores en un objeto datetime. Para referenciar a los valores que deseamos cambiar hemos de utilizar su nombre en ingl√©s.
>>> marca_temporal = datetime(2021, 7, 22, 21, 15)
>>> marca_temporal = marca_temporal.replace(month=8, minute=30)
>>> marca_temporal
datetime.datetime(2021, 8, 22, 21, 30)
# crear una fecha especifica
>>> fecha = datetime.date(2021, 7, 22)
>>> fecha.year
2021
>>> fecha.month
7
>>> fecha.day
22
# crear un horario
>>> hora = datetime.time(21, 15)
>>> hora.hour
21
>>> hora.minute
15
>>> hora.second
0
>>> hora.microsecond
0
>>> hora.isoformat()
'21:15:00'


Formatear fechas y horas
En esta secci√≥n vamos a ver dos m√©todos especiales de las clases date, time y datetime. Uno para representarlos en una cadena de caracteres (o string) formateado a nuestro gusto, y otro para crear instancias de estos objetos a partir de un string.

M√©todo .strftime()
La fecha se representa de forma distinta en diferentes pa√≠ses. Por ejemplo en Estados Unidos se usa el formato mes/d√≠a/a√±o, mientras que en Europa el formato utilizado es d√≠a/mes/a√±o. Lo mismo sucede con las horas, en algunos lugares se usa el formato de 24h y en otros prefieren el formato de 12h. Para ello tenemos el m√©todo strftime(), el cual retorna un string con la fecha o hora representada en un formato definido por nosotros mismos.

El siguiente c√≥digo Python muestra c√≥mo formatear un objeto datetime con el m√©todo strftime() a partir de un string que representa nuestro formato deseado. Si quieres saber c√≥mo crear ese string a medida, al final del art√≠culo he a√±adido una tabla con los c√≥digos que podemos utilizar. Se√±alar tambi√©n que estos mismos conceptos son aplicables a los objetos date y time.

>>> x = datetime(2021, 7, 22, 21, 15)
>>> x = x.strftime("%A, %d of %B %Y at %I:%M %p")
>>> print(x)
Thursday, 22 of July 2021 at 09:15 PM

Por defecto, los resultados que obtenemos con el m√©todo strftime() son en ingl√©s. Si queremos mostrar los resultados en espa√±ol tenemos que especificarlo con la librer√≠a locale. El siguiente ejemplo muestra c√≥mo hacerlo.

>>> import locale
>>> locale.setlocale(locale.LC_TIME, "es_ES")
'es_ES'
# Una vez completado el paso anterior los resultados ya se muestran en espa√±ol.
>>> x = datetime(2021, 7, 22, 21, 15)
>>> x = x.strftime("%A, %d de %B de %Y a las %I:%M %p")
>>> print(x)
jueves, 22 de julio de 2021 a las 09:15


M√©todo .strptime()
Este m√©todo hace justo lo contrario que el m√©todo strftime(). Es decir, crea un objeto de tipo date, time o datetime a partir de dos strings: uno que representa los valores de fecha y/o tiempo que va a tener el objeto, y otro que especifica el formato del anterior.

>>> x = datetime.strptime("22/07/2021, 21:15", "%d/%m/%Y, %H:%M")
>>> x
datetime.datetime(2021, 7, 22, 21, 15)


Tabla de c√≥digos de formato
A continuaci√≥n te dejo un tabla con los distintos c√≥digos que podemos utilizar para formatear el tiempo con los m√©todos strftime() y strptime().

Mas info: https://www.programaenpython.com/fundamentos/fechas-y-horas-en-python/

OOP Programaci√≥n Orientada a Objetos
Antes de nada, empecemos con una introducci√≥n b√°sica a la Programaci√≥n Orientada a Objetos POO o OOP en ingl√©s. Se trata de un paradigma de programaci√≥n introducido en los a√±os 1970s, pero que no se hizo popular hasta a√±os m√°s tarde.

Este modo o paradigma de programaci√≥n nos permite organizar el c√≥digo de una manera que se asemeja bastante a como pensamos en la vida real, utilizando las famosas clases. Estas nos permiten agrupar un conjunto de variables y funciones que veremos a continuaci√≥n.

Cosas de lo m√°s cotidianas como un perro o un coche pueden ser representadas con clases. Estas clases tienen diferentes caracter√≠sticas, que en el caso del perro podr√≠an ser la edad, el nombre o la raza. Llamaremos a estas caracter√≠sticas, atributos.

Por otro lado, las clases tienen un conjunto de funcionalidades o cosas que pueden hacer. En el caso del perro podr√≠a ser andar o ladrar. Llamaremos a estas funcionalidades m√©todos.

Por √∫ltimo, pueden existir diferentes tipos de perro. Podemos tener uno que se llama Toby o el del vecino que se llama Laika. Llamaremos a estos diferentes tipos de perro objetos. Es decir, el concepto abstracto de perro es la clase, pero Toby o cualquier otro perro particular ser√° el objeto.

La programaci√≥n orientada a objetos est√° basada en 6 principios o pilares b√°sicos:

Herencia
Cohesi√≥n
Abstracci√≥n
Polimorfismo
Acoplamiento
Encapsulamiento
Una vez explicada la programaci√≥n orientada a objetos puede parecer bastante l√≥gica, pero no es algo que haya existido siempre, y de hecho hay muchos lenguajes de programaci√≥n que no la soportan.

En parte surgi√≥ debido a la creciente complejidad a la que los programadores se iban enfrentando conforme pasaban los a√±os. En el mundo de la programaci√≥n hay gran cantidad de aplicaciones que realizan tareas muy similares y es importante identificar los patrones que nos permiten no reinventar la rueda. La programaci√≥n orientada a objetos intentaba resolver esto.

Uno de los primeros mecanismos que se crearon fueron las funciones, que permiten agrupar bloques de c√≥digo que hacen una tarea espec√≠fica bajo un nombre. Algo muy √∫til ya que permite tambi√©n reusar esos m√≥dulos o funciones sin tener que copiar todo el c√≥digo, tan solo la llamada.

Las funciones resultaron muy √∫tiles, pero no eran capaces de satisfacer todas las necesidades de los programadores. Uno de los problemas de las funciones es que s√≥lo realizan unas operaciones con unos datos de entrada para entregar una salida, pero no les importa demasiado conservar esos datos o mantener alg√∫n tipo de estado. Salvo que se devuelva un valor en la llamada a la funci√≥n o se usen variables globales, todo lo que pasa dentro de la funci√≥n queda olvidado, y esto en muchos casos es un problema.

Imaginemos que tenemos un juego con naves espaciales movi√©ndose por la pantalla. Cada nave tendr√° una posici√≥n (x,y) y otros par√°metros como el tipo de nave, su color o tama√±o. Sin hacer uso de clases y POO, tendremos que tener una variable para cada dato que queremos almacenar: coordenadas, color, tama√±o, tipo. El problema viene si tenemos 10 naves, ya que nos podr√≠amos juntar con un n√∫mero muy elevado de variables. Todo un desastre.

En el mundo de la programaci√≥n existen tareas muy similares al ejemplo con las naves, y en respuesta a ello surgi√≥ la programaci√≥n orientada a objetos. Una herramienta perfecta que permite resolver cierto tipo de problemas de una forma mucho m√°s sencilla, con menos c√≥digo y m√°s organizado. Agrupa bajo una clase un conjunto de variables y funciones, que pueden ser reutilizadas con caracter√≠sticas particulares creando objetos.

Definiendo clases
Vista ya la parte te√≥rica, vamos a ver como podemos hacer uso de la programaci√≥n orientada a objetos en Python. Lo primero es crear una clase, para ello usaremos el ejemplo de perro.

Creando una clase vac√≠a
class Perro:
    pass

Se trata de una clase vac√≠a y sin mucha utilidad pr√°ctica, pero es la m√≠nima clase que podemos crear. N√≥tese el uso del pass que no hace realmente nada, pero dar√≠a un error si despu√©s de los : no tenemos contenido.

Ahora que tenemos la clase, podemos crear un objeto de la misma. Podemos hacerlo como si de una variable normal se tratase. Nombre de la variable igual a la clase con (). Dentro de los par√©ntesis ir√≠an los par√°metros de entrada si los hubiera.

# Creamos un objeto de la clase perro
mi_perro = Perro()

Definiendo atributos
A continuaci√≥n vamos a a√±adir algunos atributos a nuestra clase. Antes de nada es importante distinguir que existen dos tipos de atributos:

Atributos de instancia: Pertenecen a la instancia de la clase o al objeto. Son atributos particulares de cada instancia, en nuestro caso de cada perro. Atributos de clase: Se trata de atributos que pertenecen a la clase, por lo tanto ser√°n comunes para todos los objetos. Empecemos creando un par de atributos de instancia para nuestro perro, el nombre y la raza. Para ello creamos un m√©todo init que ser√° llamado autom√°ticamente cuando creemos un objeto. Se trata del constructor.

class Perro:
    # El m√©todo __init__ es llamado al crear el objeto
    def __init__(self, nombre, raza):
        print(f"Creando perro {nombre}, {raza}")

        # Atributos de instancia
        self.nombre = nombre
        self.raza = raza


Ahora que hemos definido el m√©todo init con dos par√°metros de entrada, podemos crear el objeto pasando el valor de los atributos. Usando type() podemos ver como efectivamente el objeto es de la clase Perro.

mi_perro = Perro("Toby", "Bulldog")
print(type(mi_perro))
# Creando perro Toby, Bulldog
# <class '__main__.Perro'>

Seguramente te hayas fijado en el self que se pasa como par√°metro de entrada del m√©todo. Es una variable que representa la instancia de la clase, y deber√° estar siempre ah√≠.

El uso de __init__ y el doble __ no es una coincidencia. Cuando veas un m√©todo con esa forma, significa que est√° reservado para un uso especial del lenguaje. En este caso ser√≠a lo que se conoce como constructor. Hay gente que llama a estos m√©todos m√°gicos.

Por √∫ltimo, podemos acceder a los atributos usando el objeto y .. Por lo tanto.

print(mi_perro.nombre) # Toby
print(mi_perro.raza)   # Bulldog

Hasta ahora hemos definido atributos de instancia, ya que son atributos que pertenecen a cada perro concreto. Ahora vamos a definir un atributo de clase, que ser√° com√∫n para todos los perros. Por ejemplo, la especie de los perros es algo com√∫n para todos los objetos Perro.

class Perro:
    # Atributo de clase
    especie = 'mam√≠fero'

    # El m√©todo __init__ es llamado al crear el objeto
    def __init__(self, nombre, raza):
        print(f"Creando perro {nombre}, {raza}")

        # Atributos de instancia
        self.nombre = nombre
        self.raza = raza


Dado que es un atributo de clase, no es necesario crear un objeto para acceder al atributos. Podemos hacer lo siguiente.

print(Perro.especie)
# mam√≠fero

Se puede acceder tambi√©n al atributo de clase desde el objeto.

mi_perro = Perro("Toby", "Bulldog")
mi_perro.especie
# 'mam√≠fero'

De esta manera, todos los objetos que se creen de la clase perro compartir√°n ese atributo de clase, ya que pertenecen a la misma.

Definiendo m√©todos
En realidad cuando usamos init anteriormente ya est√°bamos definiendo un m√©todo, solo que uno especial. A continuaci√≥n vamos a ver como definir m√©todos que le den alguna funcionalidad interesante a nuestra clase, siguiendo con el ejemplo de perro.

Vamos a codificar dos m√©todos, ladrar y caminar. El primero no recibir√° ning√∫n par√°metro y el segundo recibir√° el n√∫mero de pasos que queremos andar. Como hemos indicado anteriormente self hace referencia a la instancia de la clase. Se puede definir un m√©todo con def y el nombre, y entre () los par√°metros de entrada que recibe, donde siempre tendr√° que estar self el primero.

class Perro:
    # Atributo de clase
    especie = 'mam√≠fero'

    # El m√©todo __init__ es llamado al crear el objeto
    def __init__(self, nombre, raza):
        print(f"Creando perro {nombre}, {raza}")

        # Atributos de instancia
        self.nombre = nombre
        self.raza = raza

    def ladra(self):
        print("Guau")

    def camina(self, pasos):
        print(f"Caminando {pasos} pasos")


Por lo tanto si creamos un objeto mi_perro, podremos hacer uso de sus m√©todos llam√°ndolos con . y el nombre del m√©todo. Como si de una funci√≥n se tratase, pueden recibir y devolver argumentos.

mi_perro = Perro("Toby", "Bulldog")
mi_perro.ladra()
mi_perro.camina(10)

# Creando perro Toby, Bulldog
# Guau
# Caminando 10 pasos

Herencia en Python
La herencia es un proceso mediante el cual se puede crear una clase hija que hereda de una clase padre, compartiendo sus m√©todos y atributos. Adem√°s de ello, una clase hija puede sobreescribir los m√©todos o atributos, o incluso definir unos nuevos.

Se puede crear una clase hija con tan solo pasar como par√°metro la clase de la que queremos heredar. En el siguiente ejemplo vemos como se puede usar la herencia en Python, con la clase Perro que hereda de Animal. As√≠ de f√°cil.

# Definimos una clase padre
class Animal:
    pass

# Creamos una clase hija que hereda de la padre
class Perro(Animal):
    pass

De hecho podemos ver como efectivamente la clase Perro es la hija de Animal usando bases

print(Perro.__bases__)
# (<class '__main__.Animal'>,)

De manera similar podemos ver que clases descienden de una en concreto con subclasses.

print(Animal.__subclasses__())
# [<class '__main__.Perro'>]

¬øY para que queremos la herencia? Dado que una clase hija hereda los atributos y m√©todos de la padre, nos puede ser muy √∫til cuando tengamos clases que se parecen entre s√≠ pero tienen ciertas particularidades. En este caso en vez de definir un mont√≥n de clases para cada animal, podemos tomar los elementos comunes y crear una clase Animal de la que hereden el resto, respetando por tanto la filosof√≠a DRY. Realizar estas abstracciones y buscar el denominador com√∫n para definir una clase de la que hereden las dem√°s, es una tarea de lo m√°s compleja en el mundo de la programaci√≥n.

Para saber m√°s: El principio DRY (Don't Repeat Yourself) es muy aplicado en el mundo de la programaci√≥n y consiste en no repetir c√≥digo de manera innecesaria. Cuanto m√°s c√≥digo duplicado exista, m√°s dif√≠cil ser√° de modificar y m√°s f√°cil ser√° crear inconsistencias. Las clases y la herencia a no repetir c√≥digo.

Extendiendo y modificando m√©todos
Continuemos con nuestro ejemplo de perros y animales. Vamos a definir una clase padre Animal que tendr√° todos los atributos y m√©todos gen√©ricos que los animales pueden tener. Esta tarea de buscar el denominador com√∫n es muy importante en programaci√≥n. Veamos los atributos:

Tenemos la especie ya que todos los animales pertenecen a una. Y la edad, ya que todo ser vivo nace, crece, se reproduce y muere. Y los m√©todos o funcionalidades:

Tendremos el m√©todo hablar, que cada animal implementar√° de una forma. Los perros ladran, las abejas zumban y los caballos relinchan. Un m√©todo moverse. Unos animales lo har√°n caminando, otros volando. Y por √∫ltimo un m√©todo descr√≠beme que ser√° com√∫n. Definimos la clase padre, con una serie de atributos comunes para todos los animales como hemos indicado.

class Animal:
    def __init__(self, especie, edad):
        self.especie = especie
        self.edad = edad

    # M√©todo gen√©rico pero con implementaci√≥n particular
    def hablar(self):
        # M√©todo vac√≠o
        pass

    # M√©todo gen√©rico pero con implementaci√≥n particular
    def moverse(self):
        # M√©todo vac√≠o
        pass

    # M√©todo gen√©rico con la misma implementaci√≥n
    def describeme(self):
        print("Soy un Animal del tipo", type(self).__name__)


Tenemos ya por lo tanto una clase gen√©rica Animal, que generaliza las caracter√≠sticas y funcionalidades que todo animal puede tener. Ahora creamos una clase Perro que hereda del Animal. Como primer ejemplo vamos a crear una clase vac√≠a, para ver como los m√©todos y atributos son heredados por defecto.

# Perro hereda de Animal
class Perro(Animal):
    pass

mi_perro = Perro('mam√≠fero', 10)
mi_perro.describeme()
# Soy un Animal del tipo Perro

Con tan solo un par de l√≠neas de c√≥digo, hemos creado una clase nueva que tiene todo el contenido que la clase padre tiene, pero aqu√≠ viene lo que es de verdad interesante. Vamos a crear varios animales concretos y sobreescrbir algunos de los m√©todos que hab√≠an sido definidos en la clase Animal, como el hablar o el moverse, ya que cada animal se comporta de una manera distinta.

Podemos incluso crear nuevos m√©todos que se a√±adir√°n a los ya heredados, como en el caso de la Abeja con picar().

class Perro(Animal):
    def hablar(self):
        print("Guau!")
    def moverse(self):
        print("Caminando con 4 patas")

class Vaca(Animal):
    def hablar(self):
        print("Muuu!")
    def moverse(self):
        print("Caminando con 4 patas")

class Abeja(Animal):
    def hablar(self):
        print("Bzzzz!")
    def moverse(self):
        print("Volando")

    # Nuevo m√©todo
    def picar(self):
        print("Picar!")

Por lo tanto ya podemos crear nuestros objetos de esos animales y hacer uso de sus m√©todos que podr√≠an clasificarse en tres:

Heredados directamente de la clase padre: describeme()
Heredados de la clase padre pero modificados: hablar() y moverse()
Creados en la clase hija por lo tanto no existentes en la clase padre: picar()
mi_perro = Perro('mam√≠fero', 10)
mi_vaca = Vaca('mam√≠fero', 23)
mi_abeja = Abeja('insecto', 1)

mi_perro.hablar()
mi_vaca.hablar()
# Guau!
# Muuu!

mi_vaca.describeme()
mi_abeja.describeme()
# Soy un Animal del tipo Vaca
# Soy un Animal del tipo Abeja

mi_abeja.picar()
# Picar!

Uso de super()
En pocas palabras, la funci√≥n super() nos permite acceder a los m√©todos de la clase padre desde una de sus hijas. Volvamos al ejemplo de Animal y Perro.

class Animal:
    def __init__(self, especie, edad):
        self.especie = especie
        self.edad = edad        
    def hablar(self):
        pass

    def moverse(self):
        pass

    def describeme(self):
        print("Soy un Animal del tipo", type(self).__name__)


Tal vez queramos que nuestro Perro tenga un par√°metro extra en el constructor, como podr√≠a ser el due√±o. Para realizar esto tenemos dos alternativas:

Podemos crear un nuevo init y guardar todas las variables una a una. O podemos usar super() para llamar al init de la clase padre que ya aceptaba la especie y edad, y s√≥lo asignar la variable nueva manualmente.

class Perro(Animal):
    def __init__(self, especie, edad, due√±o):
        # Alternativa 1
        # self.especie = especie
        # self.edad = edad
        # self.due√±o = due√±o

        # Alternativa 2
        super().__init__(especie, edad)
        self.due√±o = due√±o
mi_perro = Perro('mam√≠fero', 7, 'Luis')
mi_perro.especie
mi_perro.edad
mi_perro.due√±o

üöÄ Recursos de la clase
https://ellibrodepython.com/programacion-orientada-a-objetos-python